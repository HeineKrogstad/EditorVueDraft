filterPosts(posts) {
    if (!this.searchQuery) {
            return posts;
        }
    const query = this.searchQuery.toLowerCase();
    return posts.filter(post => post.content.toLowerCase().includes(query));
},
//<Tiptap v-if="showTiptap && activeTab === tab.value" :channel="tab.title" @add-post="addPost" />
//<button @click="handleClickCreatePost(tab.value)">{{ buttonCreatePostText }}</button>
{{ submitTrigger }}
@click="filterPosts"

 @add-post="addPost" :triggerSubmit="submitTrigger"







 {
    "type": "doc",
    "content": [
        {
            "type": "heading",
            "attrs": {
                "textAlign": "left",
                "level": 1
            },
            "content": [
                {
                    "type": "text",
                    "marks": [
                        {
                            "type": "textStyle",
                            "fontFamily": null,
                            "color": "#5b21b6"
                        }
                    ],
                    "text": "06.07.24"
                }
            ]
        },
        {
            "type": "paragraph",
            "attrs": {
                "textAlign": "left"
            },
            "content": [
                {
                    "type": "text",
                    "marks": [
                        {
                            "type": "textStyle",
                            "attrs": {
                                "fontFamily": null,
                                "color": "#1ac75c"
                            }
                        }
                    ],
                    "text": "asdadasdasda"
                }
            ]
        }
    ],
    "timestamp": "06.07.24",
    "id": 1720218059741
}




            <button class="btn" @click="editor.chain().focus().setTextAlign('left').run()" :class="{ 'is-active': editor.isActive({ textAlign: 'left' }) }">
                <svg-icon type="mdi" :path="mdiFormatAlignLeft"></svg-icon>
            </button>

            <button class="btn" @click="editor.chain().focus().setTextAlign('center').run()" :class="{ 'is-active': editor.isActive({ textAlign: 'center' }) }">
                <svg-icon type="mdi" :path="mdiFormatAlignCenter"></svg-icon>
            </button>

            <button class="btn" @click="editor.chain().focus().setTextAlign('right').run()" :class="{ 'is-active': editor.isActive({ textAlign: 'right' }) }">
                <svg-icon type="mdi" :path="mdiFormatAlignRight"></svg-icon>
            </button>


                        <SplitButton class="btn menu-overlay" :model="items"> 
                <template #dropdownicon>
                    <svg-icon type="mdi" :path="currentIcon" />
                </template>
                <template #item="slotProps">
                    <div class="btn mt-0.5" @click="slotProps.item.command">
                        <svg-icon type="mdi" :path="slotProps.item.icon"/>
                    </div>
                </template>
            </SplitButton>



///////////////////////////////////////////////////////////////////////////////////////


            <button class="btn" @click="addImageUploadBlock">
                <svg-icon type="mdi" :path="mdiPaperclip"></svg-icon>
            </button>

            <button @click="addImageTextBlock">Добавить блок изображения и текста</button>
            
            <button @click="addThreeImageUploadBlock">Добавить блок загрузки трех изображений</button>


                        addImageUploadBlock () {
                this.editor.chain().focus().insertContent({
                    type: 'imageUploadBlock',
                }).run()
            },

            addThreeImageUploadBlock () {
                this.editor.chain().focus().insertContent({
                    type: 'threeImageUploadBlock',
                }).run()
            },

            addImageTextBlock () {
                this.editor.chain().focus().insertContent({
                    type: 'imageTextBlock2',
                    attrs: {
                    src: null,
                    alt: 'Image',
                    },
                }).run()
            },



            export default function getEditorConfig(content = '', editable = true, tiptapExtensions = [])




                table {
        @apply overflow-x-auto w-full;
        td { @apply box-border px-2 py-3 relative align-top min-w-[30%] max-w-[70%] break-words }
        td:not(:first-child) {
            @apply border-l border-gray-300;
        }   
    }


        table {
        border-collapse: collapse;
        margin: 0;
        overflow: hidden;
        table-layout: fixed;
        width: 100%;

    td,
    th {
      border: 1px solid grey;
      box-sizing: border-box;
      min-width: 1em;
      padding: 6px 8px;
      position: relative;
      vertical-align: top;

      > * {
        margin-bottom: 0;
      }
    }

    th {
      background-color: grey;
      font-weight: bold;
      text-align: left;
    }

    .column-resize-handle {
      background-color: purple;
      bottom: -2px;
      pointer-events: none;
      position: absolute;
      right: -2px;
      top: 0;
      width: 4px;
    }
  }

  .tableWrapper {
    margin: 1.5rem 0;
    overflow-x: auto;
  }

  &.resize-cursor {
    cursor: ew-resize;
    cursor: col-resize;












    ////////////////////////////////////////
    типтак ноды
    import { Node, mergeAttributes } from '@tiptap/core';
import { defineNuxtPlugin } from '#app';

const ImageUploadBlock = Node.create({
  name: 'imageUploadBlock',

  group: 'block',

  atom: true,

  addAttributes() {
    return {
      src: {
        default: null,
      },
    }
  },

  parseHTML() {
    return [
      {
        tag: 'div[data-type="image-upload-block"]',
      },
    ]
  },

  renderHTML({ HTMLAttributes }) {
    return ['div', { 'data-type': 'image-upload-block', style: 'width: 300px; height: 300px; border: 1px dashed #ccc; display: flex; align-items: center; justify-content: center;', ...HTMLAttributes }, 
    HTMLAttributes.src ? ['img', { src: HTMLAttributes.src, style: 'max-width: 100%; max-height: 100%; display: block;' }] : 'Нажмите, чтобы загрузить изображение']
  },

  addNodeView() {
    return ({ node, getPos, editor }) => {
      const div = document.createElement('div')
      div.style.width = '300px'
      div.style.height = '300px'
      div.style.border = '1px dashed #ccc'
      div.style.display = 'flex'
      div.style.alignItems = 'center'
      div.style.justifyContent = 'center'
      div.setAttribute('data-type', 'image-upload-block')

      if (node.attrs.src) {
        const img = document.createElement('img')
        img.src = node.attrs.src
        img.style.maxWidth = '100%'
        img.style.maxHeight = '100%'
        div.appendChild(img)
      } else {
        div.innerHTML = 'Нажмите, чтобы загрузить изображение'
      }

      div.addEventListener('click', () => {
        const input = document.createElement('input')
        input.type = 'file'
        input.accept = 'image/*'
        input.onchange = (event) => {
          const file = event.target.files[0]
          if (file) {
            const reader = new FileReader()
            reader.onload = (e) => {
              const url = e.target.result
              editor.chain().focus().command(({ tr }) => {
                const pos = getPos()
                tr.setNodeMarkup(pos, null, { src: url })
                return true
              }).run()
            }
            reader.readAsDataURL(file)
          }
        }
        input.click()
      })

      return {
        dom: div,
      }
    }
  },
})

const ThreeImageUploadBlock = Node.create({
  name: 'threeImageUploadBlock',

  group: 'block',

  atom: true,

  addAttributes() {
    return {
      images: {
        default: [null, null, null],
      },
    }
  },

  parseHTML() {
    return [
      {
        tag: 'div[data-type="three-image-upload-block"]',
      },
    ]
  },

  renderHTML({ HTMLAttributes }) {
    const styles = `
      display: flex;
      justify-content: space-between;
      gap: 10px;
    `
    return ['div', { 'data-type': 'three-image-upload-block', style: styles, ...HTMLAttributes },
      ...HTMLAttributes.images.map(src => ['div', { style: 'flex: 1; height: 20rem; border: 1px dashed #ccc; display: flex; align-items: center; justify-content: center;' }, 
        src ? ['img', { src, style: 'max-width: 100%; max-height: 100%; display: block;' }] : 'Нажмите, чтобы загрузить изображение'
      ])
    ]
  },

  addNodeView() {
    return ({ node, getPos, editor }) => {
      const container = document.createElement('div')
      container.style.display = 'flex'
      container.style.justifyContent = 'space-between'
      container.style.gap = '10px'
      container.setAttribute('data-type', 'three-image-upload-block')

      node.attrs.images.forEach((src, index) => {
        const div = document.createElement('div')
        div.style.flex = '1'
        div.style.height = '20rem'
        div.style.border = '1px dashed #ccc'
        div.style.display = 'flex'
        div.style.alignItems = 'center'
        div.style.justifyContent = 'center'

        if (src) {
          const img = document.createElement('img')
          img.src = src
          img.style.maxWidth = '100%'
          img.style.maxHeight = '100%'
          div.appendChild(img)
        } else {
          div.innerHTML = 'Нажмите, чтобы загрузить изображение'
        }

        div.addEventListener('click', () => {
          const input = document.createElement('input')
          input.type = 'file'
          input.accept = 'image/*'
          input.onchange = (event) => {
            const file = event.target.files[0]
            if (file) {
              const reader = new FileReader()
              reader.onload = (e) => {
                const url = e.target.result
                const newImages = [...node.attrs.images]
                newImages[index] = url
                editor.chain().focus().command(({ tr }) => {
                  tr.setNodeMarkup(getPos(), null, { images: newImages })
                  return true
                }).run()
              }
              reader.readAsDataURL(file)
            }
          }
          input.click()
        })

        container.appendChild(div)
      })

      return {
        dom: container,
      }
    }
  },
})

const ImageTextBlock = Node.create({
  name: 'imageTextBlock',

  group: 'block',

  content: 'inline*',

  addAttributes() {
    return {
      src: {
        default: null,
      },
      alt: {
        default: 'Image',
      },
    }
  },

  parseHTML() {
    return [
      {
        tag: 'div[data-type="image-text-block"]',
      },
    ]
  },

  renderHTML({ HTMLAttributes }) {
    return ['div', { 'data-type': 'image-text-block', style: 'display: flex; align-items: center; gap: 10px;' }, 
      ['img', { src: HTMLAttributes.src, alt: HTMLAttributes.alt, style: 'width: 150px; height: 150px; object-fit: cover;' }],
      ['div', { style: 'flex: 1;' }, 0]
    ]
  },

  addNodeView() {
    return ({ node, getPos, editor }) => {
      const container = document.createElement('div')
      container.style.display = 'flex'
      container.style.alignItems = 'center'
      container.style.gap = '10px'
      container.setAttribute('data-type', 'image-text-block')

      const img = document.createElement('img')
      img.style.width = '150px'
      img.style.height = '150px'
      img.style.objectFit = 'cover'
      img.alt = node.attrs.alt

      if (node.attrs.src) {
        img.src = node.attrs.src
      } else {
        img.innerHTML = 'Нажмите, чтобы загрузить изображение'
        img.style.border = '1px dashed #ccc'
      }

      img.addEventListener('click', () => {
        const input = document.createElement('input')
        input.type = 'file'
        input.accept = 'image/*'
        input.onchange = (event) => {
          const file = event.target.files[0]
          if (file) {
            const reader = new FileReader()
            reader.onload = (e) => {
              const url = e.target.result
              editor.chain().focus().command(({ tr }) => {
                tr.setNodeMarkup(getPos(), null, { src: url })
                return true
              }).run()
            }
            reader.readAsDataURL(file)
          }
        }
        input.click()
      })

      const content = document.createElement('div')
      content.style.flex = '1'
      content.contentEditable = true

      container.appendChild(img)
      container.appendChild(content)

      return {
        dom: container,
        contentDOM: content,
      }
    }
  },
})

const ImageTextBlock2 = Node.create({
  
  name: 'imageTextBlock2',
  group: 'block',

  content: 'inline*',

  addAttributes() {
    return {
      src: {
        default: null,
      },
      alt: {
        default: 'Image',
      },
    }
  },

  parseHTML() {
    return [
      {
        tag: 'div[data-type="image-text-block"]',
      },
    ]
  },

  renderHTML({ HTMLAttributes }) {
    return [
      'div',
      { 'data-type': 'image-text-block', style: 'position: relative; display: flex; height: 20rem;' },
      [
        'div',
        {
          style: 'width: 70%; padding-right: 10px; box-sizing: border-box; overflow-y: auto;',
        },
        ['p', {}, 0]
      ],
      [
        'img',
        {
          src: HTMLAttributes.src,
          alt: HTMLAttributes.alt,
          style: 'width: 30%; position: absolute; right: 0; top: 0; height: 100%; object-fit: cover;',
        }
      ],
    ]
  },

  addNodeView() {
    return ({ node, getPos, editor }) => {
      const container = document.createElement('div');
      container.style.position = 'relative';
      container.style.display = 'flex';
      container.style.height = '20rem';
      container.setAttribute('data-type', 'image-text-block');

      const contentWrapper = document.createElement('div');
      contentWrapper.style.width = '70%';
      contentWrapper.style.paddingRight = '10px';
      contentWrapper.style.boxSizing = 'border-box';
      contentWrapper.style.overflowY = 'auto';

      const content = document.createElement('p');
      content.contentEditable = true;

      contentWrapper.appendChild(content);

      const img = document.createElement('img');
      img.style.width = '30%';
      img.style.position = 'absolute';
      img.style.right = '0';
      img.style.top = '0';
      img.style.height = '100%';
      img.style.objectFit = 'cover';
      img.alt = node.attrs.alt;

      if (node.attrs.src) {
        img.src = node.attrs.src;
      } else {
        img.innerHTML = 'Нажмите, чтобы загрузить изображение';
        img.style.border = '1px dashed #ccc';
      }

      img.addEventListener('click', () => {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = 'image/*';
        input.onchange = (event) => {
          const file = event.target.files[0];
          if (file) {
            const reader = new FileReader();
            reader.onload = (e) => {
              const url = e.target.result;
              editor.chain().focus().command(({ tr }) => {
                tr.setNodeMarkup(getPos(), null, { src: url });
                return true;
              }).run();
            };
            reader.readAsDataURL(file);
          }
        };
        input.click();
      });

      container.appendChild(contentWrapper);
      container.appendChild(img);

      return {
        dom: container,
        contentDOM: content,
      };
    };
  },
});

export default defineNuxtPlugin(nuxtApp => {
  nuxtApp.provide('tiptapExtensions', [
    //ImageUploadBlock,
    //ThreeImageUploadBlock,
    //ImageTextBlock,
    //ImageTextBlock2
  ]);
});





tiptap styles
    .menu-overlay {
        @apply flex items-center;

        ul { @apply list-none  }
        span { @apply hidden }
    }


posts.vue styles
    .date-picker { @apply focus:outline-none focus:ring-0}

    .date-picker-overlay { @apply border rounded-lg px-2 py-4}




    :class="{'border-gray-300 pt-4': tab.tiptapOpenned, 'border-violet-800 ': !tab.tiptapOpenned}" class="border rounded-lg px-4"

    flex-none mt-8